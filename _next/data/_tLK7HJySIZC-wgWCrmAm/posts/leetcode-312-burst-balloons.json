{"pageProps":{"postData":{"toc":[{"indentLevel":3,"link":"#problem-statement","headerRef":"h_0","title":"Problem statement"},{"indentLevel":3,"link":"#brute-force-solution","headerRef":"h_1","title":"Brute force "},{"indentLevel":3,"link":"#attempt-to-break-it-into-sub-problems","headerRef":"h_2","title":"Attempt to break it into sub-problems"},{"indentLevel":3,"link":"#more-optimized-way-of-solving-sub-problems","headerRef":"h_3","title":"More optimized way of solving sub-problems"}],"slug":"leetcode-312-burst-balloons","source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"problem-statement\",\n    \"className\": \"header\",\n    \"header-ref\": \"h_0\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#problem-statement\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Problem statement\"), mdx(\"p\", null, \"You are given\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \"\\xA0balloons, indexed from\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \"\\xA0to\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n - 1\"), \". Each balloon is painted with a number on it represented by an array\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \". You are asked to burst all the balloons.\"), mdx(\"p\", null, \"If you burst the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ith\"), \"\\xA0balloon, you will get\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i - 1] * nums[i] * nums[i + 1]\"), \"\\xA0coins. If\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i - 1\"), \"\\xA0or\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i + 1\"), \"\\xA0goes out of bounds of the array, then treat it as if there is a balloon with a\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \"\\xA0painted on it.\"), mdx(\"p\", null, \"Return\\xA0\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the maximum coins you can collect by bursting the balloons wisely\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Working with example:\")), mdx(\"pre\", {\n    \"className\": \"language-plain\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-plain\",\n    \"metastring\": \"text\",\n    \"text\": true\n  }, \"Input: nums = [3,1,5,8]\\nOutput: 167\\nExplanation:\\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\\n\\nThe balloon are popped in this sequence\\n1. Pop 1\\n2. Pop 5\\n3. Pop 3\\n4. Pop 8\\n\")), mdx(\"h3\", {\n    \"id\": \"brute-force-solution\",\n    \"className\": \"header\",\n    \"header-ref\": \"h_1\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#brute-force-solution\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Brute force \", mdx(\"strong\", {\n    parentName: \"h3\"\n  }, \"solution\")), mdx(\"p\", null, \"If we go by the naive solution, we can assign each number with sequence number it will be popped. This solution will yield time complexity of O(n!).\"), mdx(\"h3\", {\n    \"id\": \"attempt-to-break-it-into-sub-problems\",\n    \"className\": \"header\",\n    \"header-ref\": \"h_2\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#attempt-to-break-it-into-sub-problems\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Attempt to break it into sub-problems\"), mdx(\"p\", null, \"Can we solve this via the Divide and Conquer method by dividing the list into sub-lists and solve them individually. At each step, we select a balloon to be popped, the remaining elements will form sub-sequence of the original list.\"), mdx(\"p\", null, \"To illustrate this, given that we have a list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[3, 1, 5, 8]\")), mdx(\"pre\", {\n    \"className\": \"language-plain\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-plain\",\n    \"metastring\": \"text\",\n    \"text\": true\n  }, \"If we pop off 1 first\\nWe have to deal with [3, 5, 8] next\\n\")), mdx(\"p\", null, \"If we use such strategy, our next subproblem will going to be \", \"[3, 5, 8]\", \". We don't exactly break the list into two sublists \", \"[3]\", \" and \", \"[5, 8]\", \" and deal with them individually. Each sub-list cannot represent a subproblem. Instead, two parts of sublists are \\\"connected\\\" and contiguous in a sense. Our next step will be obtaining max gain from this merged sub-lists. We are going to exploring all \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex-mathml\"\n  }, mdx(\"math\", {\n    parentName: \"span\",\n    \"xmlns\": \"http://www.w3.org/1998/Math/MathML\"\n  }, mdx(\"semantics\", {\n    parentName: \"math\"\n  }, mdx(\"mrow\", {\n    parentName: \"semantics\"\n  }, mdx(\"msup\", {\n    parentName: \"mrow\"\n  }, mdx(\"mn\", {\n    parentName: \"msup\"\n  }, \"2\"), mdx(\"mi\", {\n    parentName: \"msup\"\n  }, \"n\"))), mdx(\"annotation\", {\n    parentName: \"semantics\",\n    \"encoding\": \"application/x-tex\"\n  }, \"2^n\")))), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex-html\",\n    \"aria-hidden\": \"true\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"base\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"0.664392em\",\n      \"verticalAlign\": \"0em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord\"\n  }, \"2\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"msupsub\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist-t\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist-r\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"vlist\",\n    \"style\": {\n      \"height\": \"0.664392em\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"style\": {\n      \"top\": \"-3.063em\",\n      \"marginRight\": \"0.05em\"\n    }\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"pstrut\",\n    \"style\": {\n      \"height\": \"2.7em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"sizing reset-size6 size3 mtight\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord mathnormal mtight\"\n  }, \"n\")))))))))))), \" possible sub-sequences whicih is undesirable, this will be an exponential growth complexity solution.\"), mdx(\"h3\", {\n    \"id\": \"more-optimized-way-of-solving-sub-problems\",\n    \"className\": \"header\",\n    \"header-ref\": \"h_3\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#more-optimized-way-of-solving-sub-problems\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"More optimized way of solving sub-problems\"), mdx(\"p\", null, \"How about we take a different approach, instead of choosing which balloon to be popped first, we reverse our thinking by selecting which balloon to be popped last. \"), mdx(\"p\", null, \"With a list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[3, 1, 5, 8,]\"), \", we pick 1 as the balloon to popped last,\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/files/64a6cbcc-e3e9-4b62-b30b-357a64182396.png\",\n    \"alt\": \"64a6cbcc-e3e9-4b62-b30b-357a64182396.png\"\n  })), mdx(\"p\", null, \"If we choose 1 as the last balloon to be popped, we are not dealing with sub-lists \", \"[3, 5]\", \" and \", \"[8]\", \" as they are contiguous. We can formulate the next problem as finding the maximum gain each from \", \"[3, 5]\", \" and \", \"[8]\", \". The maximum gain of \", \"[3, 5]\", \" and \", \"[8]\", \" are formulated not to be depending on each other (unlike the previous section). This makes the sub-list can be solved individually.\"), mdx(\"p\", null, \"We need to introduce some auxiliary setting to help deal with boundary balloons,\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/files/7ea67043-4d44-4573-8a54-745ea9d97635.png\",\n    \"alt\": \"7ea67043-4d44-4573-8a54-745ea9d97635.png\"\n  })), mdx(\"p\", null, \"We pad the list with balloon 1. Since these are paddings, we will not burst these balloons.\"), mdx(\"p\", null, \"Using this concept, we can formulate as follow:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"- This computation is repeated for each sublist.\\n\\n\\n*boundary element is element outside of the list, they can be padding OR element excluded from the sublist \\n\\n\\n\\n\\n\\nWhen we choose a balloon to be popped last, the calculation takes the balloons at far left and right (boundary, that is not included in the list) into acccount\\n\\n\\n![fdf9bcb0-a82b-4243-8243-8f334289b096.png](/files/fdf9bcb0-a82b-4243-8243-8f334289b096.png)\\n\\n\\nNotice that the calculation will at least have 3 elements, if we are evaluating sub-list of size 2, we treat it as our base case and have max gain of 0. To illustrate this, let say we have a list of zero element:\\n\\n\\n![06c2239e-7088-41b5-95fb-6d5ff086353f.png](/files/06c2239e-7088-41b5-95fb-6d5ff086353f.png)\\n\\n\\nThe auxilliary list will probably looks something like this. Since there's no element, the max gain will be zero.\\n\\n\\n\\n\\n\\nWhen we compute the max gain of a list, we will try all possible choices of balloon to be popped last\\n\\n\\n![bd0a189c-21cd-4ffc-a015-56b3300d390b.png](/files/bd0a189c-21cd-4ffc-a015-56b3300d390b.png)\\n\\n\\nWhen we burst the balloon at index k, we can get:\\n\\n\\n- DP[i,k]\\xA0(Maximum coins collected by bursting balloons[(i+1)\\u2026(k-1)]) +\\n\\n\\n- DP[k,j]\\xA0(Maximum coins collected by bursting balloons[(k+1)\\u2026(j-1)]) +\\n\\n\\n- nums[i] * nums[k] * nums[j]\\n\\n\\n### Let's get into the programming\\n\\n\\n__Flow of the program__\\n\\n\\n1. Define\\xA0A[] = {1, nums[0], nums[1], \\u2026, nums[n-1], 1}\\xA0of size\\xA0(n+2). Let these represent the balloons.\\n\\n\\n2. Define an DP matrix of size (n+2)*(n+2),\\xA0such that\\xA0DP[i][j] (j > i)\\xA0represents the maximum coins collected by bursting balloons\\xA0[(i+1)\\u2026(j-1)].\\n\\n\\n3. (Base Case)\\xA0DP[i][i+1] = 0\\xA0because we have no ballons to burst.\\n\\n\\n4. DP[i][j]\\xA0= Max (\\xA0DP[i][k] + DP[k][j] + (nums[i]*nums[k]*nums[j]), where\\xA0(i+1)\\u2264 k \\u2264 (j-1)\\xA0).\\n\\n\\n5. Final answer is\\xA0DP[0, n+1].\\n\\n\\nDepends on the approach that we use, if we going for top-down, we would solve the problem from the entire list. If we take the bottom-up approach, we can solve from sublist from size 2 and onwards.\\n\\n\\n__Solution:__\\n\\n\\n``` java\\n\")), mdx(\"p\", null, \"class Solution {\\npublic int maxCoins(int[] nums) {\\n//DP CUT STRATEGY LIKE MCM\\nint arr[] = new int\", \"[nums.length + 2]\", \";\\narr\", \"[0]\", \" = arr\", \"[arr.length-1]\", \" = 1;\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    for(int i = 0 ; i < nums.length ; i++)\\n        arr[i+1] = nums[i]; \\n    \\n    int dp[][] = new int[arr.length+1][arr.length+1];\\n    return burstbaloon(arr , dp); \\n}\\n\\npublic int burstbaloon(int[] arr , int[][] dp) {\\n    \\n    for(int gap = 1 ; gap <= arr.length - 2; gap++) {\\n        // (gap + 1): length spanned by the gap and right pivot\\n        for(int left = 0 ; left < arr.length - (gap + 1); left++) {\\n            int right = left + gap + 1;\\n            \\n            // we set the left and right boundary\\n            // and experiment with each of the balloon (in the range) to be the last to pop\\n            System.out.println(left + \\\", \\\" + right);\\n            \\n            for(int i = left +1 ; i < right ; i++) {\\n                System.out.println(\\\"Popping \\\" + i);\\n                dp[left][right] = Math.max(dp[left][right] , (dp[left][i] + dp[i][right] + (arr[left]*arr[right]*arr[i]))); \\n            }\\n        }\\n    }\\n    \\n    return dp[0][arr.length-1];\\n}\\n\")), mdx(\"p\", null, \"}\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n\\n    ### Runtime Analysis\\n\\n\\n    The DP table has\\xA0`O(N\\xB2)`\\xA0entries. To compute each entry, we are looking at all the possible choices for the last balloon to be burst and taking the maximum one. There are\\xA0`O(N)`\\xA0choices in the worst case at each step and for each choice computing the coins collected is an\\xA0`O(1)`\\xA0operation.Thus, computing each entry of\\xA0`DP[][]`\\xA0takes\\xA0`O(N) * O(1) = O(N)`\\xA0time.Hence, the overall runtime is\\xA0`O(N\\xB2) x O(N) = O(N\\xB3)`.\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h3 id=\"problem-statement\" class=\"header\" header-ref=\"h_0\"><a href=\"#problem-statement\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Problem statement</h3><p>You are given <code>n</code> balloons, indexed from <code>0</code> to <code>n - 1</code>. Each balloon is painted with a number on it represented by an array <code>nums</code>. You are asked to burst all the balloons.</p><p>If you burst the <code>ith</code> balloon, you will get <code>nums[i - 1] * nums[i] * nums[i + 1]</code> coins. If <code>i - 1</code> or <code>i + 1</code> goes out of bounds of the array, then treat it as if there is a balloon with a <code>1</code> painted on it.</p><p>Return <em>the maximum coins you can collect by bursting the balloons wisely</em>.</p><p><strong>Working with example:</strong></p><pre class=\"language-plain\"><code class=\"language-plain\" metastring=\"text\">Input: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n\nThe balloon are popped in this sequence\n1. Pop 1\n2. Pop 5\n3. Pop 3\n4. Pop 8\n</code></pre><h3 id=\"brute-force-solution\" class=\"header\" header-ref=\"h_1\"><a href=\"#brute-force-solution\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Brute force <strong>solution</strong></h3><p>If we go by the naive solution, we can assign each number with sequence number it will be popped. This solution will yield time complexity of O(n!).</p><h3 id=\"attempt-to-break-it-into-sub-problems\" class=\"header\" header-ref=\"h_2\"><a href=\"#attempt-to-break-it-into-sub-problems\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Attempt to break it into sub-problems</h3><p>Can we solve this via the Divide and Conquer method by dividing the list into sub-lists and solve them individually. At each step, we select a balloon to be popped, the remaining elements will form sub-sequence of the original list.</p><p>To illustrate this, given that we have a list of <code>[3, 1, 5, 8]</code></p><pre class=\"language-plain\"><code class=\"language-plain\" metastring=\"text\">If we pop off 1 first\nWe have to deal with [3, 5, 8] next\n</code></pre><p>If we use such strategy, our next subproblem will going to be <!-- -->[3, 5, 8]<!-- -->. We don&#x27;t exactly break the list into two sublists <!-- -->[3]<!-- --> and <!-- -->[5, 8]<!-- --> and deal with them individually. Each sub-list cannot represent a subproblem. Instead, two parts of sublists are &quot;connected&quot; and contiguous in a sense. Our next step will be obtaining max gain from this merged sub-lists. We are going to exploring all <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em\"><span style=\"top:-3.063em;margin-right:0.05em\"><span class=\"pstrut\" style=\"height:2.7em\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> possible sub-sequences whicih is undesirable, this will be an exponential growth complexity solution.</p><h3 id=\"more-optimized-way-of-solving-sub-problems\" class=\"header\" header-ref=\"h_3\"><a href=\"#more-optimized-way-of-solving-sub-problems\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>More optimized way of solving sub-problems</h3><p>How about we take a different approach, instead of choosing which balloon to be popped first, we reverse our thinking by selecting which balloon to be popped last. </p><p>With a list of <code>[3, 1, 5, 8,]</code>, we pick 1 as the balloon to popped last,</p><p><img src=\"/files/64a6cbcc-e3e9-4b62-b30b-357a64182396.png\" alt=\"64a6cbcc-e3e9-4b62-b30b-357a64182396.png\"/></p><p>If we choose 1 as the last balloon to be popped, we are not dealing with sub-lists <!-- -->[3, 5]<!-- --> and <!-- -->[8]<!-- --> as they are contiguous. We can formulate the next problem as finding the maximum gain each from <!-- -->[3, 5]<!-- --> and <!-- -->[8]<!-- -->. The maximum gain of <!-- -->[3, 5]<!-- --> and <!-- -->[8]<!-- --> are formulated not to be depending on each other (unlike the previous section). This makes the sub-list can be solved individually.</p><p>We need to introduce some auxiliary setting to help deal with boundary balloons,</p><p><img src=\"/files/7ea67043-4d44-4573-8a54-745ea9d97635.png\" alt=\"7ea67043-4d44-4573-8a54-745ea9d97635.png\"/></p><p>We pad the list with balloon 1. Since these are paddings, we will not burst these balloons.</p><p>Using this concept, we can formulate as follow:</p><pre><code>- This computation is repeated for each sublist.\n\n\n*boundary element is element outside of the list, they can be padding OR element excluded from the sublist \n\n\n\n\n\nWhen we choose a balloon to be popped last, the calculation takes the balloons at far left and right (boundary, that is not included in the list) into acccount\n\n\n![fdf9bcb0-a82b-4243-8243-8f334289b096.png](/files/fdf9bcb0-a82b-4243-8243-8f334289b096.png)\n\n\nNotice that the calculation will at least have 3 elements, if we are evaluating sub-list of size 2, we treat it as our base case and have max gain of 0. To illustrate this, let say we have a list of zero element:\n\n\n![06c2239e-7088-41b5-95fb-6d5ff086353f.png](/files/06c2239e-7088-41b5-95fb-6d5ff086353f.png)\n\n\nThe auxilliary list will probably looks something like this. Since there&#x27;s no element, the max gain will be zero.\n\n\n\n\n\nWhen we compute the max gain of a list, we will try all possible choices of balloon to be popped last\n\n\n![bd0a189c-21cd-4ffc-a015-56b3300d390b.png](/files/bd0a189c-21cd-4ffc-a015-56b3300d390b.png)\n\n\nWhen we burst the balloon at index k, we can get:\n\n\n- DP[i,k] (Maximum coins collected by bursting balloons[(i+1)…(k-1)]) +\n\n\n- DP[k,j] (Maximum coins collected by bursting balloons[(k+1)…(j-1)]) +\n\n\n- nums[i] * nums[k] * nums[j]\n\n\n### Let&#x27;s get into the programming\n\n\n__Flow of the program__\n\n\n1. Define A[] = {1, nums[0], nums[1], …, nums[n-1], 1} of size (n+2). Let these represent the balloons.\n\n\n2. Define an DP matrix of size (n+2)*(n+2), such that DP[i][j] (j &gt; i) represents the maximum coins collected by bursting balloons [(i+1)…(j-1)].\n\n\n3. (Base Case) DP[i][i+1] = 0 because we have no ballons to burst.\n\n\n4. DP[i][j] = Max ( DP[i][k] + DP[k][j] + (nums[i]*nums[k]*nums[j]), where (i+1)≤ k ≤ (j-1) ).\n\n\n5. Final answer is DP[0, n+1].\n\n\nDepends on the approach that we use, if we going for top-down, we would solve the problem from the entire list. If we take the bottom-up approach, we can solve from sublist from size 2 and onwards.\n\n\n__Solution:__\n\n\n``` java\n</code></pre><p>class Solution {\npublic int maxCoins(int[] nums) {\n//DP CUT STRATEGY LIKE MCM\nint arr[] = new int<!-- -->[nums.length + 2]<!-- -->;\narr<!-- -->[0]<!-- --> = arr<!-- -->[arr.length-1]<!-- --> = 1;</p><pre><code>    for(int i = 0 ; i &lt; nums.length ; i++)\n        arr[i+1] = nums[i]; \n    \n    int dp[][] = new int[arr.length+1][arr.length+1];\n    return burstbaloon(arr , dp); \n}\n\npublic int burstbaloon(int[] arr , int[][] dp) {\n    \n    for(int gap = 1 ; gap &lt;= arr.length - 2; gap++) {\n        // (gap + 1): length spanned by the gap and right pivot\n        for(int left = 0 ; left &lt; arr.length - (gap + 1); left++) {\n            int right = left + gap + 1;\n            \n            // we set the left and right boundary\n            // and experiment with each of the balloon (in the range) to be the last to pop\n            System.out.println(left + &quot;, &quot; + right);\n            \n            for(int i = left +1 ; i &lt; right ; i++) {\n                System.out.println(&quot;Popping &quot; + i);\n                dp[left][right] = Math.max(dp[left][right] , (dp[left][i] + dp[i][right] + (arr[left]*arr[right]*arr[i]))); \n            }\n        }\n    }\n    \n    return dp[0][arr.length-1];\n}\n</code></pre><p>}</p><pre><code>\n\n    ### Runtime Analysis\n\n\n    The DP table has `O(N²)` entries. To compute each entry, we are looking at all the possible choices for the last balloon to be burst and taking the maximum one. There are `O(N)` choices in the worst case at each step and for each choice computing the coins collected is an `O(1)` operation.Thus, computing each entry of `DP[][]` takes `O(N) * O(1) = O(N)` time.Hence, the overall runtime is `O(N²) x O(N) = O(N³)`.\n</code></pre>","scope":{}},"wordCount":1055,"readingTime":5,"title":"Leetcode 312: Burst Balloons","date":"2021-05-26","description":"Solving leetcode #312","tags":["Leetcode","Dynamic Programming"]}},"__N_SSG":true}