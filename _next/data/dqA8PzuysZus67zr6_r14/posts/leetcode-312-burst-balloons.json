{"pageProps":{"postData":{"slug":"leetcode-312-burst-balloons","source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Problem statement\"), mdx(\"p\", null, \"You are given\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \"\\xA0balloons, indexed from\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \"\\xA0to\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n - 1\"), \". Each balloon is painted with a number on it represented by an array\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums\"), \". You are asked to burst all the balloons.\"), mdx(\"p\", null, \"If you burst the\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ith\"), \"\\xA0balloon, you will get\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nums[i - 1] * nums[i] * nums[i + 1]\"), \"\\xA0coins. If\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i - 1\"), \"\\xA0or\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i + 1\"), \"\\xA0goes out of bounds of the array, then treat it as if there is a balloon with a\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \"\\xA0painted on it.\"), mdx(\"p\", null, \"Return\\xA0\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"the maximum coins you can collect by bursting the balloons wisely\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Working with example:\")), mdx(\"pre\", {\n    \"className\": \"language-plain\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-plain\",\n    \"metastring\": \"text\",\n    \"text\": true\n  }, \"Input: nums = [3,1,5,8]\\nOutput: 167\\nExplanation:\\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\\n\\nThe balloon are popped in this sequence\\n1. Pop 1\\n2. Pop 5\\n3. Pop 3\\n4. Pop 8\\n\")), mdx(\"h3\", null, \"Brute force solution\"), mdx(\"p\", null, \"If we go by the naive solution, we can assign each number with sequence number it will be popped. This solution will yield time complexity of O(n!).\"), mdx(\"h3\", null, \"Attempt to break it into sub-problems\"), mdx(\"p\", null, \"Can we solve this via the Divide and Conquer method by dividing the list into sub-lists and solve them individually. At each step, we select a balloon to be popped, the remaining elements will form sub-sequence of the original list.\"), mdx(\"p\", null, \"To illustrate this, given that we have a list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[3, 1, 5, 8]\")), mdx(\"pre\", {\n    \"className\": \"language-plain\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-plain\",\n    \"metastring\": \"text\",\n    \"text\": true\n  }, \"If we pop off 1 first\\nWe have to deal with [3, 5, 8] next\\n\")), mdx(\"p\", null, \"If we use such strategy, our next subproblem will going to be \", \"[3, 5, 8]\", \". We don't exactly break the list into two sublists \", \"[3]\", \" and \", \"[5, 8]\", \" and deal with them individually. Each sub-list cannot represent a subproblem. Instead, two parts of sublists are \\\"connected\\\" and contiguous in a sense. Our next step will be obtaining max gain from this merged sub-lists. We are going to exploring all $ 2^n $ possible sub-sequences which is undesirable, this will be an exponential growth complexity solution.\"), mdx(\"h3\", null, \"More optimized way of solving sub-problems\"), mdx(\"p\", null, \"How about we take a different approach, instead of choosing which balloon to be popped first, we reverse our thinking by selecting which balloon to be popped last. \"), mdx(\"p\", null, \"With a list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[3, 1, 5, 8,]\"), \", we pick 1 as the balloon to popped last,\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/files/4fe60d0f.png\",\n    \"alt\": \"Untitled\"\n  })), mdx(\"p\", null, \"If we choose 1 as the last balloon to be popped, we are not dealing with sub-lists \", \"[3, 5]\", \" and \", \"[8]\", \" as they are contiguous. We can formulate the next problem as finding the maximum gain each from \", \"[3, 5]\", \" and \", \"[8]\", \". The maximum gain of \", \"[3, 5]\", \" and \", \"[8]\", \" are formulated not to be depending on each other (unlike the previous section). This makes the sub-list can be solved individually.\"), mdx(\"p\", null, \"We need to introduce some auxiliary setting to help deal with boundary balloons,\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/files/8604993f.png\",\n    \"alt\": \"Untitled\"\n  })), mdx(\"p\", null, \"We pad the list with balloon 1. Since these are paddings, we will not burst these balloons.\"), mdx(\"p\", null, \"Using this concept, we can formulate as follow:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"To compute the max gain, DP of a list, we have to compute:\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"max(DP(left_sublist) + (balloon that we remove at last* boundary elements) + DP(right_sublist))\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"This computation is repeated for each sublist.\"))), mdx(\"p\", null, \"*boundary element is element outside of the list, they can be padding OR element excluded from the sublist \"), mdx(\"p\", null, \"When we choose a balloon to be popped last, the calculation takes the balloons at far left and right (boundary, that is not included in the list) into account.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/files/b29a93c3.png\",\n    \"alt\": \"Untitled\"\n  })), mdx(\"p\", null, \"Notice that the calculation will at least have 3 elements, if we are evaluating sub-list of size 2, we treat it as our base case and have max gain of 0. To illustrate this, let say we have a list of zero element:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/files/6444ab25.png\",\n    \"alt\": \"Untitled\"\n  })), mdx(\"p\", null, \"The auxiliary list will probably looks something like this. Since there's no element, the max gain will be zero.\"), mdx(\"p\", null, \"When we compute the max gain of a list, we will try all possible choices of balloon to be popped last\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/files/7b93e010.png\",\n    \"alt\": \"Untitled\"\n  })), mdx(\"p\", null, \"Green: Balloon to be popped last, Purple: Left sublist, Blue: Right sublist\"), mdx(\"p\", null, \"When we burst the balloon at index k, we can get:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"DP\", \"[i,k]\", \"\\xA0(Maximum coins collected by bursting balloons\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[(i+1)\\u2026(k-1)]\"), \") +\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"DP\", \"[k,j]\", \"\\xA0(Maximum coins collected by bursting balloons\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[(k+1)\\u2026(j-1)]\"), \") +\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"nums\", \"[i]\", \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" nums\", \"[k]\", \" \"), \" nums\", \"[j]\"))), mdx(\"h3\", null, \"Let's get into the programming\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Flow of the program\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Define\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*A[] = {1, nums[0], nums[1], \\u2026, nums[n-1], 1}*\"), \"*\\xA0*of size\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(n+2)\"), \". Let these represent the balloons.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Define an DP matrix of size (n+2)*(n+2),\\xA0such that\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DP[i][j] (j > i)\"), \"\\xA0represents the maximum coins collected by bursting balloons\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[(i+1)\\u2026(j-1)]\"), \".\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"(Base Case)\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DP[i][i+1] = 0\"), \"\\xA0because we have no ballons to burst.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DP[i][j]\"), \"\\xA0= Max (\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DP[i][k] + DP[k][j] + (nums[i]*nums[k]*nums[j])\"), \", where\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(i+1)\\u2264 k \\u2264 (j-1)\"), \"\\xA0).\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Final answer is\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DP[0, n+1]\"), \".\"))), mdx(\"p\", null, \"Depends on the approach that we use, if we going for top-down, we would solve the problem from the entire list. If we take the bottom-up approach, we can solve from sublist from size 2 and onwards.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Solution:\")), mdx(\"pre\", {\n    \"className\": \"language-java\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"class\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"Solution\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"public\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"maxCoins\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" nums\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token comment\"\n  }, \"//DP CUT STRATEGY LIKE MCM \"), \"\\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"new\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"nums\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"2\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n        arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n        \\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"for\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" i \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" i \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<\"), \" nums\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"++\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n            arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" nums\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" \\n        \\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"new\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"return\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"burstbaloon\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"arr \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" \\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n    \\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"public\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"burstbaloon\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" arr \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n        \\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"for\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" gap \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" gap \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<=\"), \" arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"2\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" gap\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"++\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n            \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token comment\"\n  }, \"// (gap + 1): length spanned by the gap and right pivot\"), \"\\n            \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"for\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" left \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" left \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<\"), \" arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"gap \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" left\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"++\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n                \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" right \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" left \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" gap \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n                \\n                \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token comment\"\n  }, \"// we set the left and right boundary\"), \"\\n                \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token comment\"\n  }, \"// and experiment with each of the balloon (in the range) to be the last to pop\"), \"\\n                \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"System\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"out\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"println\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"left \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\", \\\"\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" right\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n                \\n                \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"for\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"int\"), \" i \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" left \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" i \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<\"), \" right \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"++\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n                    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"System\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"out\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"println\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"Popping \\\"\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n                    dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"left\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"right\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"Math\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"max\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"left\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"right\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"left\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"right\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"left\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"*\"), \"arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"right\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"*\"), \"arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"i\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \" \\n                \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n            \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n        \\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"return\"), \" dp\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"arr\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"length\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n\")), mdx(\"h3\", null, \"Runtime Analysis\"), mdx(\"p\", null, \"The DP table has\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(N\\xB2)\"), \"\\xA0entries. To compute each entry, we are looking at all the possible choices for the last balloon to be burst and taking the maximum one. There are\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(N)\"), \"\\xA0choices in the worst case at each step and for each choice computing the coins collected is an\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(1)\"), \"\\xA0operation.Thus, computing each entry of\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DP[][]\"), \"\\xA0takes\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(N) * O(1) = O(N)\"), \"\\xA0time.Hence, the overall runtime is\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(N\\xB2) x O(N) = O(N\\xB3)\"), \".\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h3>Problem statement</h3><p>You are given <code>n</code> balloons, indexed from <code>0</code> to <code>n - 1</code>. Each balloon is painted with a number on it represented by an array <code>nums</code>. You are asked to burst all the balloons.</p><p>If you burst the <code>ith</code> balloon, you will get <code>nums[i - 1] * nums[i] * nums[i + 1]</code> coins. If <code>i - 1</code> or <code>i + 1</code> goes out of bounds of the array, then treat it as if there is a balloon with a <code>1</code> painted on it.</p><p>Return <em>the maximum coins you can collect by bursting the balloons wisely</em>.</p><p><strong>Working with example:</strong></p><pre class=\"language-plain\"><code class=\"language-plain\" metastring=\"text\">Input: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n\nThe balloon are popped in this sequence\n1. Pop 1\n2. Pop 5\n3. Pop 3\n4. Pop 8\n</code></pre><h3>Brute force solution</h3><p>If we go by the naive solution, we can assign each number with sequence number it will be popped. This solution will yield time complexity of O(n!).</p><h3>Attempt to break it into sub-problems</h3><p>Can we solve this via the Divide and Conquer method by dividing the list into sub-lists and solve them individually. At each step, we select a balloon to be popped, the remaining elements will form sub-sequence of the original list.</p><p>To illustrate this, given that we have a list of <code>[3, 1, 5, 8]</code></p><pre class=\"language-plain\"><code class=\"language-plain\" metastring=\"text\">If we pop off 1 first\nWe have to deal with [3, 5, 8] next\n</code></pre><p>If we use such strategy, our next subproblem will going to be <!-- -->[3, 5, 8]<!-- -->. We don&#x27;t exactly break the list into two sublists <!-- -->[3]<!-- --> and <!-- -->[5, 8]<!-- --> and deal with them individually. Each sub-list cannot represent a subproblem. Instead, two parts of sublists are &quot;connected&quot; and contiguous in a sense. Our next step will be obtaining max gain from this merged sub-lists. We are going to exploring all $ 2^n $ possible sub-sequences which is undesirable, this will be an exponential growth complexity solution.</p><h3>More optimized way of solving sub-problems</h3><p>How about we take a different approach, instead of choosing which balloon to be popped first, we reverse our thinking by selecting which balloon to be popped last. </p><p>With a list of <code>[3, 1, 5, 8,]</code>, we pick 1 as the balloon to popped last,</p><p><img src=\"/files/4fe60d0f.png\" alt=\"Untitled\"/></p><p>If we choose 1 as the last balloon to be popped, we are not dealing with sub-lists <!-- -->[3, 5]<!-- --> and <!-- -->[8]<!-- --> as they are contiguous. We can formulate the next problem as finding the maximum gain each from <!-- -->[3, 5]<!-- --> and <!-- -->[8]<!-- -->. The maximum gain of <!-- -->[3, 5]<!-- --> and <!-- -->[8]<!-- --> are formulated not to be depending on each other (unlike the previous section). This makes the sub-list can be solved individually.</p><p>We need to introduce some auxiliary setting to help deal with boundary balloons,</p><p><img src=\"/files/8604993f.png\" alt=\"Untitled\"/></p><p>We pad the list with balloon 1. Since these are paddings, we will not burst these balloons.</p><p>Using this concept, we can formulate as follow:</p><ul><li><p>To compute the max gain, DP of a list, we have to compute:</p><p>max(DP(left_sublist) + (balloon that we remove at last* boundary elements) + DP(right_sublist))</p></li><li><p>This computation is repeated for each sublist.</p></li></ul><p>*boundary element is element outside of the list, they can be padding OR element excluded from the sublist </p><p>When we choose a balloon to be popped last, the calculation takes the balloons at far left and right (boundary, that is not included in the list) into account.</p><p><img src=\"/files/b29a93c3.png\" alt=\"Untitled\"/></p><p>Notice that the calculation will at least have 3 elements, if we are evaluating sub-list of size 2, we treat it as our base case and have max gain of 0. To illustrate this, let say we have a list of zero element:</p><p><img src=\"/files/6444ab25.png\" alt=\"Untitled\"/></p><p>The auxiliary list will probably looks something like this. Since there&#x27;s no element, the max gain will be zero.</p><p>When we compute the max gain of a list, we will try all possible choices of balloon to be popped last</p><p><img src=\"/files/7b93e010.png\" alt=\"Untitled\"/></p><p>Green: Balloon to be popped last, Purple: Left sublist, Blue: Right sublist</p><p>When we burst the balloon at index k, we can get:</p><ul><li><p>DP<!-- -->[i,k]<!-- --> (Maximum coins collected by bursting balloons<code>[(i+1)…(k-1)]</code>) +</p></li><li><p>DP<!-- -->[k,j]<!-- --> (Maximum coins collected by bursting balloons<code>[(k+1)…(j-1)]</code>) +</p></li><li><p>nums<!-- -->[i]<!-- --> <em> nums<!-- -->[k]<!-- --> </em> nums<!-- -->[j]</p></li></ul><h3>Let&#x27;s get into the programming</h3><p><strong>Flow of the program</strong></p><ol><li><p>Define <code>*A[] = {1, nums[0], nums[1], …, nums[n-1], 1}*</code>* *of size <code>(n+2)</code>. Let these represent the balloons.</p></li><li><p>Define an DP matrix of size (n+2)*(n+2), such that <code>DP[i][j] (j &gt; i)</code> represents the maximum coins collected by bursting balloons <code>[(i+1)…(j-1)]</code>.</p></li><li><p>(Base Case) <code>DP[i][i+1] = 0</code> because we have no ballons to burst.</p></li><li><p><code>DP[i][j]</code> = Max ( <code>DP[i][k] + DP[k][j] + (nums[i]*nums[k]*nums[j])</code>, where <code>(i+1)≤ k ≤ (j-1)</code> ).</p></li><li><p>Final answer is <code>DP[0, n+1]</code>.</p></li></ol><p>Depends on the approach that we use, if we going for top-down, we would solve the problem from the entire list. If we take the bottom-up approach, we can solve from sublist from size 2 and onwards.</p><p><strong>Solution:</strong></p><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxCoins</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//DP CUT STRATEGY LIKE MCM </span>\n        <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            arr<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n        \n        <span class=\"token keyword\">int</span> dp<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">burstbaloon</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">burstbaloon</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> gap <span class=\"token operator\">&lt;=</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> gap<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// (gap + 1): length spanned by the gap and right pivot</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> left <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>gap <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> left<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> left <span class=\"token operator\">+</span> gap <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                \n                <span class=\"token comment\">// we set the left and right boundary</span>\n                <span class=\"token comment\">// and experiment with each of the balloon (in the range) to be the last to pop</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> <span class=\"token string\">&quot;, &quot;</span> <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                \n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> left <span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> right <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">&quot;Popping &quot;</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    dp<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>arr<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><h3>Runtime Analysis</h3><p>The DP table has <code>O(N²)</code> entries. To compute each entry, we are looking at all the possible choices for the last balloon to be burst and taking the maximum one. There are <code>O(N)</code> choices in the worst case at each step and for each choice computing the coins collected is an <code>O(1)</code> operation.Thus, computing each entry of <code>DP[][]</code> takes <code>O(N) * O(1) = O(N)</code> time.Hence, the overall runtime is <code>O(N²) x O(N) = O(N³)</code>.</p>","scope":{}},"wordCount":1094,"readingTime":5,"title":"Leetcode 312: Burst Balloons","section":"blog","id":"927f06657f174c60815f26baca51f7f6","date":"2021-05-26","tags":["Leetcode","Dynamic Programming"]}},"__N_SSG":true}